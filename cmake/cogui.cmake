cmake_minimum_required(VERSION 3.25.0)

if(NOT WIN32)
  string(ASCII 27 Esc)
  set(ColourReset "${Esc}[m")
  set(ColourBold  "${Esc}[1m")
  set(Red         "${Esc}[31m")
  set(Green       "${Esc}[32m")
  set(Yellow      "${Esc}[33m")
  set(Blue        "${Esc}[34m")
  set(Magenta     "${Esc}[35m")
  set(Cyan        "${Esc}[36m")
  set(White       "${Esc}[37m")
  set(BoldRed     "${Esc}[1;31m")
  set(BoldGreen   "${Esc}[1;32m")
  set(BoldYellow  "${Esc}[1;33m")
  set(BoldBlue    "${Esc}[1;34m")
  set(BoldMagenta "${Esc}[1;35m")
  set(BoldCyan    "${Esc}[1;36m")
  set(BoldWhite   "${Esc}[1;37m")
endif()

if(CMAKE_USE_EXTRA_DEBUG)
    set(CMAKE_EXTRA_DEBUG 1)
endif()

#
# Macro to traverse all the subdirectories of a specific directory
#
macro(Subdirlist result curdir)
  FILE(GLOB children RELATIVE ${curdir} ${curdir}/*)
  SET(dirlist "")
  FOREACH(child ${children})
    IF(IS_DIRECTORY ${curdir}/${child})
      LIST(APPEND dirlist ${child})
    ENDIF()
  ENDFOREACH()
  SET(${result} ${dirlist})
endmacro()

#
# Enumerates the objects at a given location, and builds up the required structures
#
function(EnumerateObjects type location target_var)

  set(INCLUDE_RESULTS "")
  set(all_objects "")

  message("\n## Enumerating ${type}s at ${location}")
  Subdirlist(subdirs ${location})

  # looping through the directory. The subdir variable will hold both the name of the subdirectory but also the name of the current type (theme, engine, etc...)
  FOREACH(subdir ${subdirs})

    # Did we find a directory at the given location
    message(STATUS "${type} found at: ${subdir}")

    # Reading the file
    file(READ ${location}/${subdir}/descr.json ${subdir}_json_content)
    sbeParseJson(${subdir}_json ${subdir}_json_content)

    # check will be set to 2 if the current object has the required platform and renderer
    set("${subdir}_check" "0")

    foreach(var ${${subdir}_json})

      if(CMAKE_EXTRA_DEBUG)
        message("-- ${theme} using as: ${var} = ${${var}}")
      endif()

      # Theme platform matches? It might be an array, so we check 2 elements max
      # since there is support for 2 platforms right now: linux and windows
      if("${var}" STREQUAL "${subdir}_json.${type}.platform"
              OR "${var}" STREQUAL "${subdir}_json.${type}.platform_0"
              OR "${var}" STREQUAL "${subdir}_json.${type}.platform_1")
        if(${${var}} STREQUAL ${TargetPlatform})
          message(STATUS "Platform match: ${subdir} (${type}) has the right platform: ${TargetPlatform}")
          math(EXPR "${subdir}_check" "${${subdir}_check} + 1")
        endif()
      endif()

      # Theme mode mathces?
      if("${var}" STREQUAL "${subdir}_json.${type}.mode")
        if(${${var}} STREQUAL ${TargetRenderer})
          message(STATUS "Renderer match: ${subdir} (${type}) has the right mode: ${TargetRenderer}")
          math(EXPR "${subdir}_check" "${${subdir}_check} + 1")
        endif()
      endif()

    endforeach(var ${${subdir}_json})

    # Do we accept the theme?
    if(${subdir}_check EQUAL 2)
      message("** ${subdir} accepted, initializing")
      list(APPEND INCLUDE_RESULTS "${type}s/${subdir}/${${subdir}_json.${type}.name}.h")
      list(APPEND all_objects ${subdir})

      message("Entering subidr: ${type}s/${subdir}")
      add_subdirectory("${type}s/${subdir}")

      set(options_callback_provided FALSE)
      set(callback_function_name "")

      # Check if a callback function name is provided as the last argument
      if(ARGC GREATER 3)
        set(callback_function_name ${ARGV3})
        set(options_callback_provided TRUE)
      endif()

      # Check if the callback should be called
      if(options_callback_provided)
        message("Callback function detected: ${callback_function_name}")
        cmake_language(CALL ${callback_function_name} ${subdir})
      else()
        message("No callback function provided.")
      endif()

      message("** ${subdir} accepted, initialized")
    endif()

  ENDFOREACH(subdir ${subdirs})

  set(STYPE ${type})
  string(TOUPPER ${type} STYPE)

  file(WRITE ${CMAKE_BINARY_DIR}/${type}s.h "/* Autogenerated by CMake on ${TIMEZ}. All changes to this file will be lost*/\n")
  file(APPEND ${CMAKE_BINARY_DIR}/${type}s.h "#ifndef _COGUI_${STYPE}S_H_\n#define _COGUI_${STYPE}S_H_\n")
  file(APPEND ${CMAKE_BINARY_DIR}/${type}s.h "/** Autogenerated on ${TIMEZ} */\n")
  foreach(header ${INCLUDE_RESULTS})
    file(APPEND ${CMAKE_BINARY_DIR}/${type}s.h "#include \"${header}\"\n")
  endforeach()
  file(APPEND ${CMAKE_BINARY_DIR}/${type}s.h "#endif\n")

  # Generate the cpp file for the theme's install directory
  file(WRITE ${CMAKE_BINARY_DIR}/${type}s.cpp "#include <${type}.h>\n")
  file(APPEND ${CMAKE_BINARY_DIR}/${type}s.cpp "const char* cogui::${type}::type=\"${type}\";\n")
  file(APPEND ${CMAKE_BINARY_DIR}/${type}s.cpp "const char* cogui::${type}::path=\"${CMAKE_INSTALL_PREFIX}/lib/cogui/${type}s\";\n")

  # Identify the first theme
  list(LENGTH all_objects obj_cnt)
  message("object count: ${obj_cnt}")
  if(obj_cnt GREATER_EQUAL 1)
    set(${target_var} ${all_objects} PARENT_SCOPE)

    set(str_all_objects "")
    # Loop through each string in the list
    foreach(string IN LISTS all_objects)
      if(str_all_objects STREQUAL "") # If the result is empty, just set it
        set(str_all_objects "${string}")
      else() # Otherwise, append the delimiter and the string
        set(str_all_objects "${str_all_objects}\", \"${string}")
      endif()
    endforeach()

    # JoinStrings(str_all_objects "\", \""  ${all_objects})
    file(APPEND ${CMAKE_BINARY_DIR}/${type}s.cpp "std::vector<std::string> g_s_all_${type}s={\"${str_all_objects}\"};\n")

    list(GET all_objects 0 main_theme)
    file(APPEND ${CMAKE_BINARY_DIR}/${type}s.cpp "std::string g_s_${type}_name = \"${main_theme}\";\n")
  endif()

endfunction(EnumerateObjects)

#
# Function to add the theme implementation to the specific library of the theme
#
FUNCTION (InjectThemeImplementation THEME)
  
  target_sources(${THEME} PUBLIC
    ${CMAKE_SOURCE_DIR}/themes/theme_impl.cpp
  )

ENDFUNCTION()
